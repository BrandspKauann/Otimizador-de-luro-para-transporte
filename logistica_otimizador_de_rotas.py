# -*- coding: utf-8 -*-
"""Logistica - Otimizador de rotas

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BFqD1AluCleKm7kAVWAnaN5z_xqEWiAM
"""

import networkx as nx
import matplotlib.pyplot as plt

# -------------------------------------------------------
# 1) Criar um mapa artificial (pequena malha viária)
# -------------------------------------------------------

G = nx.Graph()

# Coordenadas dos nós (apenas para visualização no mapa)
pos = {
    "A": (0, 2),
    "B": (1, 3),
    "C": (3, 3),
    "D": (4, 2),
    "E": (3, 1),
    "F": (1, 1),
}

# Arestas com distâncias (pesos)
edges = [
    ("A", "B", 2),
    ("B", "C", 2),
    ("C", "D", 2),
    ("D", "E", 2),
    ("E", "F", 2),
    ("F", "A", 2),

    # Rotas internas (ineficientes)
    ("B", "F", 4),
    ("C", "E", 4),
]

G.add_weighted_edges_from(edges)

# -------------------------------------------------------
# 2) Definir origem e destino
# -------------------------------------------------------
origin = "A"
destination = "D"

# -------------------------------------------------------
# 3) Computar menor rota (Dijkstra)
# -------------------------------------------------------
shortest_path = nx.shortest_path(G, origin, destination, weight="weight")
shortest_path_edges = list(zip(shortest_path[:-1], shortest_path[1:]))

# -------------------------------------------------------
# 4) Plotar mapa
# -------------------------------------------------------
plt.figure(figsize=(10, 6))

# Plot das ruas (todas em vermelho = ineficiente)
nx.draw(G, pos, with_labels=True, node_size=900, node_color="#333333",
        edge_color="red", width=3, font_color="white")

# Plot da rota otimizada (verde)
nx.draw_networkx_edges(
    G, pos,
    edgelist=shortest_path_edges,
    width=6,
    edge_color="lime"
)

# Título estilo da imagem enviada
plt.title("Comparison of Routes\nRed = Inefficient   |   Green = Optimized (Dijkstra)")

# Mostrar
plt.axis("off")
plt.show()

print("Rota ótima encontrada:", " → ".join(shortest_path))
print("Distância total:", nx.path_weight(G, shortest_path, "weight"))

import networkx as nx
import matplotlib.pyplot as plt
from queue import PriorityQueue, deque

# -------------------------------------------------------
# Usar o mesmo grafo G e pos da etapa anterior
# -------------------------------------------------------

# 1) Algoritmo: BFS (sem pesos)
def bfs_path(G, start, goal):
    visited = set()
    queue = deque([(start, [start])])

    while queue:
        node, path = queue.popleft()
        if node == goal:
            return path
        for neigh in G.neighbors(node):
            if neigh not in visited:
                visited.add(neigh)
                queue.append((neigh, path + [neigh]))
    return None

# 2) Algoritmo: DFS (pode gerar caminhos ruins)
def dfs_path(G, start, goal):
    stack = [(start, [start])]
    visited = set()

    while stack:
        node, path = stack.pop()
        if node == goal:
            return path
        for neigh in G.neighbors(node):
            if neigh not in visited:
                visited.add(neigh)
                stack.append((neigh, path + [neigh]))
    return None

# 3) Greedy Best-First Search
def greedy_best_first_search(G, start, goal):
    def heuristic(node):
        (x1, y1) = pos[node]
        (x2, y2) = pos[goal]
        return ((x1-x2)**2 + (y1-y2)**2)**0.5

    pq = PriorityQueue()
    pq.put((0, start, [start]))
    visited = set()

    while not pq.empty():
        h, node, path = pq.get()
        if node == goal:
            return path

        visited.add(node)
        for neigh in G.neighbors(node):
            if neigh not in visited:
                pq.put((heuristic(neigh), neigh, path + [neigh]))

    return None

# 4) A* Search
def astar_path(G, start, goal):
    return nx.astar_path(G, start, goal, heuristic=lambda u,v: 0)

# 5) Dijkstra (já tínhamos)
dijkstra_path = nx.dijkstra_path(G, "A", "D")

# -------------------------------------------------------
# Calcular caminhos
# -------------------------------------------------------
paths = {
    "Dijkstra": dijkstra_path,
    "A*": astar_path(G, "A", "D"),
    "Greedy": greedy_best_first_search(G, "A", "D"),
    "BFS": bfs_path(G, "A", "D"),
    "DFS": dfs_path(G, "A", "D"),
}

# -------------------------------------------------------
# Calcular custos de cada caminho
# -------------------------------------------------------
def cost(path):
    return nx.path_weight(G, path, weight="weight")

results = {k: (v, cost(v)) for k, v in paths.items()}

# -------------------------------------------------------
# Mostrar ranking
# -------------------------------------------------------
print("===== RANKING DE ALGORITMOS =====")
for name, (path, c) in results.items():
    print(f"{name}: Custo = {c}, Rota = {' → '.join(path)}")

# -------------------------------------------------------
# Plot lado-a-lado
# -------------------------------------------------------
fig, axes = plt.subplots(1, 5, figsize=(25, 5))

for ax, (name, (path, c)) in zip(axes, results.items()):
    ax.set_title(name + f"\nCusto = {c}")

    # todas ruas em cinza
    nx.draw(G, pos, ax=ax, with_labels=True, node_size=700,
            node_color="#444", edge_color="lightgray", width=3)

    # rota do algoritmo em destaque
    edges_path = list(zip(path[:-1], path[1:]))
    nx.draw_networkx_edges(G, pos, ax=ax,
                           edgelist=edges_path,
                           width=6,
                           edge_color="lime")

    ax.axis("off")

plt.tight_layout()
plt.show()

import networkx as nx
import matplotlib.pyplot as plt

# ===============================
# 1. Criar grafo mais complexo
# ===============================
G = nx.Graph()

arestas = [
    ("A","B",4), ("A","C",2), ("A","D",7),
    ("B","E",5), ("B","F",3),
    ("C","F",4), ("C","G",6),
    ("D","G",3), ("D","H",8),
    ("E","I",7),
    ("F","I",2), ("F","J",6),
    ("G","J",4),
    ("H","J",5),
    ("I","K",3),
    ("J","K",2)
]

for u,v,w in arestas:
    G.add_edge(u, v, weight=w)

# ===============================
# 2. Definir origem e destino
# ===============================
origem = "A"
destino = "K"

# ===============================
# 3. Calcular rota ótima (Dijkstra)
# ===============================
rota = nx.shortest_path(G, origem, destino, weight='weight')
dist = nx.shortest_path_length(G, origem, destino, weight='weight')

print("===== ROTA COMPLEXA =====")
print("Melhor rota:", " → ".join(rota))
print("Distância total:", dist)

# ===============================
# 4. Plotar o grafo e destacar a rota
# ===============================
plt.figure(figsize=(12, 8))

pos = nx.spring_layout(G, seed=42)

# Plot nodos e arestas normais
nx.draw_networkx_nodes(G, pos, node_size=900, node_color="#cccccc")
nx.draw_networkx_edges(G, pos, width=2, edge_color="#aaaaaa")

# Destacar rota ótima
edges_rota = list(zip(rota, rota[1:]))
nx.draw_networkx_edges(G, pos, edgelist=edges_rota, width=4, edge_color="green")

# Labels
nx.draw_networkx_labels(G, pos, font_size=12, font_weight="bold")

labels_pesos = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels_pesos)

plt.title("Rota Ótima (Dijkstra) – Grafo Complexo")
plt.axis("off")
plt.show()

