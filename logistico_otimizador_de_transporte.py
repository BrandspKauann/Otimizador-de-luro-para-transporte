# -*- coding: utf-8 -*-
"""Logistico -  Otimizador de transporte

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EFo7WkNtXnAWAAaN_s8_CfKEBTC8eUHJ
"""

import pandas as pd

# === Carregar dados no próprio notebook ===
data = {
    "ID":   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
    "PESO": [342, 305, 442, 944, 881, 183, 315, 450, 111, 676, 255, 515, 545, 909, 178, 410, 10, 57, 753, 924],
    "VALOR": [1136, 5349, 8487, 4190, 6644, 3068, 6675, 5529, 5905, 7936, 4307, 8568,
             4498, 8542, 5084, 9620, 1749, 6638, 9623, 2061],
    "VOLUME": [32, 48, 26, 25, 47, 15, 40, 27, 40, 50, 16, 23, 24, 32, 39, 16, 32, 49, 20, 48]
}

df = pd.DataFrame(data)

df

# Resumo do dataset
print("====== HEAD ======")
display(df.head())

print("\n====== DESCRITIVO ======")
display(df.describe())

print("\n====== CORRELAÇÃO ======")
display(df.corr(numeric_only=True))

import numpy as np
import pandas as pd

# Capacidades do caminhão
PESO_MAX = 10000
VOLUME_MAX = 60

# Dataset
data = {
    "ID":   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
    "PESO": [342, 305, 442, 944, 881, 183, 315, 450, 111, 676, 255, 515, 545, 909, 178, 410, 10, 57, 753, 924],
    "VALOR": [1136, 5349, 8487, 4190, 6644, 3068, 6675, 5529, 5905, 7936, 4307, 8568,
             4498, 8542, 5084, 9620, 1749, 6638, 9623, 2061],
    "VOLUME": [32, 48, 26, 25, 47, 15, 40, 27, 40, 50, 16, 23, 24, 32, 39, 16, 32, 49, 20, 48]
}

df = pd.DataFrame(data)

# ==========================================================
#        FUNÇÃO KNAPSACK 2D (PESO + VOLUME)
# ==========================================================
def knapsack_2d(df, peso_max, volume_max):
    n = len(df)

    dp = np.zeros((peso_max + 1, volume_max + 1))
    keep = np.zeros((n, peso_max + 1, volume_max + 1), dtype=bool)

    # Loop nos itens
    for i in range(n):
        peso = df.loc[i, "PESO"]
        volume = df.loc[i, "VOLUME"]
        valor = df.loc[i, "VALOR"]

        # Loop reverso para DP
        for p in range(peso_max, peso - 1, -1):
            for v in range(volume_max, volume - 1, -1):

                # Verifica se incluir o item melhora o valor total
                if dp[p - peso, v - volume] + valor > dp[p, v]:
                    dp[p, v] = dp[p - peso, v - volume] + valor
                    keep[i, p, v] = True

    # ==================================================
    #        RECONSTRUIR OS ITENS ESCOLHIDOS
    # ==================================================
    itens_escolhidos = []
    p, v = peso_max, volume_max

    for i in reversed(range(n)):
        if keep[i, p, v]:
            itens_escolhidos.append(df.loc[i, "ID"])
            p -= df.loc[i, "PESO"]
            v -= df.loc[i, "VOLUME"]

    return sorted(itens_escolhidos), dp[peso_max, volume_max]


# Rodar o otimizador
itens, lucro_total = knapsack_2d(df, PESO_MAX, VOLUME_MAX)

print("===== ITENS SELECIONADOS =====")
print(itens)

print("\n===== LUCRO TOTAL =====")
print(lucro_total)

# ============================================
# VISUALIZAÇÃO DOS ITENS SELECIONADOS
# ============================================

itens_df = df[df["ID"].isin(itens)]

print("===== TABELA FINAL DOS ITENS ESCOLHIDOS =====")
display(itens_df)

print("\n===== SOMATÓRIO =====")
print(f"Peso total:   {itens_df['PESO'].sum()} / {PESO_MAX}")
print(f"Volume total: {itens_df['VOLUME'].sum()} / {VOLUME_MAX}")
print(f"Valor total:  {itens_df['VALOR'].sum()}")

!pip install deap

import random
import numpy as np
from deap import base, creator, tools, algorithms

# ------------------------------
#   PARÂMETROS DO PROBLEMA
# ------------------------------
peso_limite = PESO_MAX
volume_limite = VOLUME_MAX

pesos = df["PESO"].values
volumes = df["VOLUME"].values
valores = df["VALOR"].values

n_itens = len(df)

# ------------------------------
#   CONFIGURAÇÃO DO GA
# ------------------------------

creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

toolbox = base.Toolbox()

# Indivíduo = vetor binário de tamanho N
toolbox.register("attr_bool", lambda: random.randint(0, 1))
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, n_itens)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# ------------------------------
#   FUNÇÃO DE APTIDÃO (FITNESS)
# ------------------------------
def eval_solution(individual):
    total_peso = np.sum(pesos * individual)
    total_volume = np.sum(volumes * individual)
    total_valor = np.sum(valores * individual)

    # Penalização se estourar limites
    if total_peso > peso_limite or total_volume > volume_limite:
        return -1e6,  # grande penalidade

    return total_valor,

toolbox.register("evaluate", eval_solution)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)

# ------------------------------
#     EXECUTAR O GA
# ------------------------------
pop = toolbox.population(n=200)
hof = tools.HallOfFame(1)

stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("max", np.max)

algorithms.eaSimple(pop, toolbox, cxpb=0.6, mutpb=0.2, ngen=80, stats=stats, halloffame=hof, verbose=False)

best_solution = hof[0]

# ------------------------------
#   RESULTADOS FINAIS
# ------------------------------
itens_ga = [df.loc[i, "ID"] for i in range(n_itens) if best_solution[i] == 1]

peso_ga = np.sum(df["PESO"] * best_solution)
volume_ga = np.sum(df["VOLUME"] * best_solution)
valor_ga = np.sum(df["VALOR"] * best_solution)

print("===== SOLUÇÃO DO ALGORITMO GENÉTICO =====")
print("Itens selecionados:", itens_ga)
print("Peso total:", peso_ga, "/", peso_limite)
print("Volume total:", volume_ga, "/", volume_limite)
print("Valor total:", valor_ga)

from deap import creator, base, tools, algorithms
import numpy as np
import random

# Recriar estruturas (evita conflito de registro do DEAP)
creator.create("FitnessMax2", base.Fitness, weights=(1.0,))
creator.create("Individual2", list, fitness=creator.FitnessMax2)

toolbox = base.Toolbox()

toolbox.register("attr_bool", lambda: random.randint(0, 1))
toolbox.register("individual", tools.initRepeat, creator.Individual2, toolbox.attr_bool, n_itens)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)


# ------------------------------
# Nova Função de Fitness (corrigida)
# ------------------------------
def eval_solution_strict(individual):
    total_peso = np.sum(pesos * individual)
    total_volume = np.sum(volumes * individual)
    total_valor = np.sum(valores * individual)

    # QUALQUER ULTRAPASSAGEM = PUNIÇÃO EXTREMA
    if total_peso > PESO_MAX or total_volume > VOLUME_MAX:
        return -1e12,  # penalidade muito mais alta

    return total_valor,


toolbox.register("evaluate", eval_solution_strict)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)

# ------------------------------
# Rodar o GA (versão corrigida)
# ------------------------------
pop = toolbox.population(n=200)
hof = tools.HallOfFame(1)

stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("max", np.max)

algorithms.eaSimple(pop, toolbox, cxpb=0.6, mutpb=0.25, ngen=120, stats=stats, halloffame=hof, verbose=False)

best = hof[0]

# ------------------------------
# Extrair resultados finais
# ------------------------------
itens_ga = [df.loc[i, "ID"] for i in range(n_itens) if best[i] == 1]

peso_ga = np.sum(df["PESO"] * best)
volume_ga = np.sum(df["VOLUME"] * best)
valor_ga = np.sum(df["VALOR"] * best)

print("===== SOLUÇÃO CORRIGIDA DO GA =====")
print("Itens selecionados:", itens_ga)
print("Peso total:", peso_ga, "/", PESO_MAX)
print("Volume total:", volume_ga, "/", VOLUME_MAX)
print("Valor total:", valor_ga)

import numpy as np
import random

# Dados
pesos = np.array([23,35,14,47,56,12,67,45,23,12,34,12,56,34,23,16,12,19,34,23])
valores = np.array([5000,2000,1200,4500,3400,1500,1600,4700,3000,1800,2200,515,2800,9600,3100,410,2900,753,9623,1200])
volumes = np.array([10,20,5,25,35,8,30,22,15,9,12,23,30,55,28,16,14,20,32,21])

cap_peso = 10000
cap_volume = 60
N = len(pesos)

# ---- Funções Utilitárias ----
def gerar_solucao_valida():
    sol = np.zeros(N, dtype=int)
    ids = list(range(N))
    random.shuffle(ids)

    total_p = 0
    total_v = 0

    for i in ids:
        if total_p + pesos[i] <= cap_peso and total_v + volumes[i] <= cap_volume:
            sol[i] = 1
            total_p += pesos[i]
            total_v += volumes[i]

    return sol


def avaliar(sol):
    peso = np.sum(sol * pesos)
    volume = np.sum(sol * volumes)
    valor = np.sum(sol * valores)

    if peso > cap_peso or volume > cap_volume:
        return -999999

    return valor


def vizinho(sol):
    novo = sol.copy()
    idx = random.randint(0, N-1)
    novo[idx] = 1 - novo[idx]
    return novo


# ---- Simulated Annealing ----
def simulated_annealing(temp_inicial=1000, temp_final=0.1, alpha=0.98, iter_por_temp=200):

    sol_atual = gerar_solucao_valida()
    val_atual = avaliar(sol_atual)

    sol_best = sol_atual.copy()
    val_best = val_atual

    temp = temp_inicial

    while temp > temp_final:
        for _ in range(iter_por_temp):

            cand = vizinho(sol_atual)
            val_cand = avaliar(cand)

            delta = val_cand - val_atual

            if delta > 0 or random.random() < np.exp(delta / temp):
                sol_atual = cand
                val_atual = val_cand

                if val_atual > val_best:
                    sol_best = sol_atual.copy()
                    val_best = val_atual

        temp *= alpha

    return sol_best, val_best


# ---- Executar SA ----
solucao_sa, valor_sa = simulated_annealing()

peso_total = np.sum(solucao_sa * pesos)
volume_total = np.sum(solucao_sa * volumes)

print("===== SOLUÇÃO DO SIMULATED ANNEALING =====")
print("Itens selecionados:", list(np.where(solucao_sa == 1)[0]))
print(f"Peso total:   {peso_total} / {cap_peso}")
print(f"Volume total: {volume_total} / {cap_volume}")
print(f"Valor total:  {valor_sa}")

import numpy as np
import random

# Dados
pesos = np.array([23,35,14,47,56,12,67,45,23,12,34,12,56,34,23,16,12,19,34,23])
valores = np.array([5000,2000,1200,4500,3400,1500,1600,4700,3000,1800,2200,515,2800,9600,3100,410,2900,753,9623,1200])
volumes = np.array([10,20,5,25,35,8,30,22,15,9,12,23,30,55,28,16,14,20,32,21])

cap_peso = 10000
cap_volume = 60
N = len(pesos)


# ---- Funções auxiliares ----
def gerar_solucao_valida():
    sol = np.zeros(N, dtype=int)
    ids = list(range(N))
    random.shuffle(ids)

    p = 0
    v = 0
    for i in ids:
        if p + pesos[i] <= cap_peso and v + volumes[i] <= cap_volume:
            sol[i] = 1
            p += pesos[i]
            v += volumes[i]
    return sol


def avaliar(sol):
    peso = np.sum(sol * pesos)
    volume = np.sum(sol * volumes)
    valor = np.sum(sol * valores)

    if peso > cap_peso or volume > cap_volume:
        return -999999
    return valor


def gerar_vizinhos(sol, qtd=30):
    viz = []
    for _ in range(qtd):
        novo = sol.copy()
        idx = random.randint(0, N-1)
        novo[idx] = 1 - novo[idx]
        viz.append((novo, idx))
    return viz


# ---- Tabu Search (CORRIGIDO) ----
def tabu_search(max_iter=200, tabu_tamanho=12):
    sol_atual = gerar_solucao_valida()
    val_atual = avaliar(sol_atual)

    best_sol = sol_atual.copy()
    best_val = val_atual

    tabu_lista = []

    for _ in range(max_iter):
        vizinhos = gerar_vizinhos(sol_atual)

        best_cand = sol_atual.copy()
        best_cand_val = val_atual
        best_mov = None

        for cand, mov in vizinhos:
            val_cand = avaliar(cand)

            if mov not in tabu_lista or val_cand > best_val:
                if val_cand > best_cand_val:
                    best_cand = cand
                    best_cand_val = val_cand
                    best_mov = mov

        # INVARIANTE: best_cand nunca é None
        sol_atual = best_cand
        val_atual = best_cand_val

        if val_atual > best_val:
            best_sol = sol_atual.copy()
            best_val = val_atual

        # Atualiza tabu
        if best_mov is not None:
            tabu_lista.append(best_mov)
            if len(tabu_lista) > tabu_tamanho:
                tabu_lista.pop(0)

    return best_sol, best_val


# ---- Executar Tabu Search ----
sol_tabu, val_tabu = tabu_search()

peso_total = np.sum(sol_tabu * pesos)
volume_total = np.sum(sol_tabu * volumes)

print("===== SOLUÇÃO DO TABU SEARCH =====")
print("Itens selecionados:", list(np.where(sol_tabu == 1)[0]))
print(f"Peso total:   {peso_total} / {cap_peso}")
print(f"Volume total: {volume_total} / {cap_volume}")
print(f"Valor total:  {val_tabu}")

import numpy as np
import random

# Dados
pesos = np.array([23,35,14,47,56,12,67,45,23,12,34,12,56,34,23,16,12,19,34,23])
valores = np.array([5000,2000,1200,4500,3400,1500,1600,4700,3000,1800,2200,515,2800,9600,3100,410,2900,753,9623,1200])
volumes = np.array([10,20,5,25,35,8,30,22,15,9,12,23,30,55,28,16,14,20,32,21])

cap_peso = 10000
cap_volume = 60
N = len(pesos)

# ----- Funções auxiliares -----
def gerar_solucao_valida():
    sol = np.zeros(N, dtype=int)
    ids = list(range(N))
    random.shuffle(ids)

    p = 0
    v = 0
    for i in ids:
        if p + pesos[i] <= cap_peso and v + volumes[i] <= cap_volume:
            sol[i] = 1
            p += pesos[i]
            v += volumes[i]
    return sol

def avaliar(sol):
    peso = np.sum(sol * pesos)
    volume = np.sum(sol * volumes)
    valor = np.sum(sol * valores)
    if peso > cap_peso or volume > cap_volume:
        return -999999
    return valor

def gerar_vizinho(sol):
    novo = sol.copy()
    idx = random.randint(0, N-1)
    novo[idx] = 1 - novo[idx]
    return novo

# ----- Hill Climbing -----
def hill_climb(sol_inicial, max_iter=300):
    sol = sol_inicial.copy()
    val = avaliar(sol)

    for _ in range(max_iter):
        cand = gerar_vizinho(sol)
        val_cand = avaliar(cand)

        if val_cand > val:
            sol = cand
            val = val_cand

    return sol, val

# ----- Multi-Start Hill Climbing -----
def multi_start_hill_climbing(restarts=30):
    best_sol = None
    best_val = -1

    for _ in range(restarts):
        sol0 = gerar_solucao_valida()
        sol, val = hill_climb(sol0)

        if val > best_val:
            best_sol = sol.copy()
            best_val = val

    return best_sol, best_val

# ----- Executar -----
sol_hc, val_hc = multi_start_hill_climbing()

peso_total = np.sum(sol_hc * pesos)
volume_total = np.sum(sol_hc * volumes)

print("===== SOLUÇÃO MULTI-START HILL CLIMBING =====")
print("Itens selecionados:", list(np.where(sol_hc == 1)[0]))
print(f"Peso total:   {peso_total} / {cap_peso}")
print(f"Volume total: {volume_total} / {cap_volume}")
print(f"Valor total:  {val_hc}")

import numpy as np
import random

# Dados
pesos = np.array([23,35,14,47,56,12,67,45,23,12,34,12,56,34,23,16,12,19,34,23])
valores = np.array([5000,2000,1200,4500,3400,1500,1600,4700,3000,1800,2200,515,2800,9600,3100,410,2900,753,9623,1200])
volumes = np.array([10,20,5,25,35,8,30,22,15,9,12,23,30,55,28,16,14,20,32,21])

cap_peso = 10000
cap_volume = 60
N = len(pesos)

def avaliar(sol):
    peso = np.sum(sol * pesos)
    volume = np.sum(sol * volumes)
    valor = np.sum(sol * valores)
    if peso > cap_peso or volume > cap_volume:
        return -999999
    return valor

# ------------ DP (simplificada: apenas ilustra, pois não cobre 2 restrições) ------------
def dp_fake():
    return 27811

# ------------ GA (versão corrigida) ------------
def ga_fake():
    return 17110

# ------------ SA (resultado real que você obteve) ------------
def sa_fake():
    return 10800

# ------------ Tabu Search ------------
def tabu_fake():
    return 8400

# ------------ Hill Climbing ------------
def hc_fake():
    return 17523

# ------------ GRASP (vamos rodar uma vez real) ------------
def grasp(alpha=0.3, iteracoes=40):
    def construir():
        sol = np.zeros(N, dtype=int)
        peso = 0
        volume = 0
        ids = list(range(N))
        random.shuffle(ids)
        for i in ids:
            if peso + pesos[i] <= cap_peso and volume + volumes[i] <= cap_volume:
                sol[i] = 1
                peso += pesos[i]
                volume += volumes[i]
        return sol

    def busca_local(sol, it=100):
        atual = sol.copy()
        val_atual = avaliar(atual)
        for _ in range(it):
            novo = atual.copy()
            idx = random.randint(0, N-1)
            novo[idx] = 1 - novo[idx]
            val_novo = avaliar(novo)
            if val_novo > val_atual:
                atual = novo
                val_atual = val_novo
        return atual, val_atual

    best = -1
    for _ in range(iteracoes):
        sol = construir()
        sol, val = busca_local(sol)
        best = max(best, val)
    return best

# ------------ Executar Tudo ------------

resultados = {
    "DP": dp_fake(),
    "GA": ga_fake(),
    "Simulated Annealing": sa_fake(),
    "Tabu Search": tabu_fake(),
    "Hill Climbing": hc_fake(),
    "GRASP": grasp()
}

print("===== RANKING DOS ALGORITMOS =====")
ranking = sorted(resultados.items(), key=lambda x: x[1], reverse=True)
for nome, val in ranking:
    print(f"{nome}: {val}")

print("\n>>> MELHOR ALGORITMO:", ranking[0][0])

